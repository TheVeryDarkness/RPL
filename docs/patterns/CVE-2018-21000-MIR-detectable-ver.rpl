pattern CVE-2018-21000

patt {
    use alloc::vec::Vec;
    use core::ptr::non_null::NonNull;
    use core::ptr::unique::Unique;
    use alloc::raw_vec::Cap;
    use alloc::raw_vec::RawVecInner;
    use alloc::raw_vec::RawVec;
    use alloc::alloc::Global;
    use core::marker::PhantomData;

    p_u8_to_t_misordered_para[
        $T: type
    ] = #[mir] unsafe fn _ (..) -> _ {
        let $from_vec: Vec::<u8> = _;
        let mut $from_vec_mut_borrow: &mut Vec::<u8> = &mut $from_vec;
        let mut $from_vec_non_null: NonNull::<u8> = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer;
        let mut $from_vec_const_ptr: *const u8 = copy ($from_vec_non_null.pointer);
        let mut $from_vec_mut_ptr: *mut u8 =copy $from_vec_const_ptr as *mut u8 (PtrToPtr);
        let mut $from_vec_inmutable_borrow_1: &Vec::<u8> = &$from_vec;
        let mut $from_vec_inmutable_borrow_2: &Vec::<u8> = &$from_vec;
        let mut $from_vec_cap: usize = copy (*$from_vec_inmutable_borrow_1).buf.inner.cap.0;
        let mut $tsize1: usize = SizeOf($T);
        let mut $tsize2: usize = SizeOf($T);
        let mut $to_vec_cap: usize = Div(move $from_vec_cap, move $tsize1);
        let mut $from_vec_len: usize = copy (*$from_vec_inmutable_borrow_2).len;
        let $to_vec_len: usize = Div(move $from_vec_len, move $tsize2);
        let mut $to_vec_mut_ptr: *mut $T = copy $from_vec_mut_ptr as *mut $T (PtrToPtr);
        let $to_vec_wrong_cap_1: Cap = #[Ctor] Cap(copy $to_vec_len);
        let mut $to_vec_wrong_cap_2: Cap = move $to_vec_wrong_cap_1;
        let mut $to_vec_const_ptr: *const u8 = copy $to_vec_mut_ptr as *const u8 (PtrToPtr);
        let mut $to_vec_non_null: NonNull::<u8> = NonNull::<u8> { 
            pointer: copy $to_vec_const_ptr 
        };
        let mut $to_vec_unique: Unique::<u8> = Unique::<u8> { 
            pointer: move $to_vec_non_null, 
            _marker: const PhantomData::<u8> 
        };
        let mut $to_vec_raw_inner: RawVecInner = RawVecInner { 
            ptr: move $to_vec_unique, 
            cap: copy $to_vec_wrong_cap_2, 
            alloc: Global
        };
        let mut $to_vec_raw: RawVec::<$T> = RawVec::<$T> {
            inner: move $to_vec_raw_inner, 
            _marker: PhantomData::<$T> 
        };
        let mut $to_vec: Vec::<$T> = Vec::<$T> { 
            buf: move $to_vec_raw, 
            len: copy $to_vec_cap 
        };
    }
    
    p_t_to_u8_misordered_para[
        $T: ty
    ] = #[mir] unsafe fn _ (..) -> _ {
        let $from_vec: Vec::<$T> = _;
        let mut $from_vec_inmutable_borrow_1: &Vec::<$T> = &$from_vec;
        let mut $from_vec_cap: usize = copy (*$from_vec_inmutable_borrow_1).buf.inner.cap.0;
        let mut $tsize1: usize = SizeOf($T);
        let mut $to_vec_cap: usize = Mul(move $from_vec_cap, move $tsize1);
        let mut $from_vec_inmutable_borrow_2: &Vec::<$T> = &$from_vec;
        let mut $from_vec_len: usize = copy (*$from_vec_inmutable_borrow_2).len;
        let mut $tsize2: usize = SizeOf($T);
        let $to_vec_len: usize = Mul(move $from_vec_len, move $tsize2);
        let mut $from_vec_mut_borrow: &mut Vec::<$T> = &mut $from_vec;
        let mut $from_vec_non_null: NonNull::<u8> = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer;
        let mut $from_vec_const_ptr: *const u8 = copy ($from_vec_non_null.pointer);
        let mut $from_vec_mut_ptr: *mut $T = copy $from_vec_const_ptr as *mut $T (PtrToPtr);
        let mut $to_vec_mut_ptr: *mut u8 = copy $from_vec_mut_ptr as *mut u8 (PtrToPtr);
        let $to_vec_wrong_cap: Cap = #[Ctor] Cap(copy $to_vec_len);
        let mut $to_vec_non_null: NonNull::<u8> = NonNull::<u8> { 
            pointer: copy $to_vec_mut_ptr 
        };
        let mut $to_vec_unique: Unique::<u8> = Unique::<u8> { 
            pointer: move $to_vec_non_null, 
            _marker: const PhantomData::<u8> 
        };
        let mut $to_vec_raw_inner: RawVecInner = RawVecInner { 
            ptr: move $to_vec_unique, 
            cap: copy $to_vec_wrong_cap, 
            alloc: const Global
        };
        let mut $to_vec_raw: RawVec::<u8> = RawVec::<u8, Global> {
            inner: move $to_vec_raw_inner, 
            _marker: const PhantomData::<u8> 
        };
        let mut $to_vec: Vec::<u8> = Vec::<u8, Global> { 
            buf: move $to_vec_raw, 
            len: copy $to_vec_cap 
        };
    }
}