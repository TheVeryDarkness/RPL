pattern CVE-2020-35892-3

patt {
    // p_loop[
    //     $T: type
    // ] = {
    //     struct $SlabT {
    //         $mem: *mut $T,
    //         $len: usize,
    //     }

    //     fn _(..) -> _ {
    //         let $self: &mut $SlabT;
    //         let $len: usize;
    //         let $x1: usize;
    //         let $x2: usize;
    //         let $opt: #[lang = "Option"]<usize>;
    //         let $discr: isize;
    //         let $x: usize;
    //         let $start_ref: &usize;
    //         let $end_ref: &usize;
    //         let $start: usize;
    //         let $end: usize;
    //         let $range: core::ops::range::Range<usize>;
    //         let mut $iter: core::ops::range::Range<usize>;
    //         let mut $iter_mut: &mut core::ops::range::Range<usize>;
    //         let mut $base: *mut $T;
    //         let $offset: isize;
    //         let $elem_ptr: *mut $T;
    //         let $cmp: bool;

    //         $len = copy (*$self).$len;
    //         $range = core::ops::range::Range { start: const 0_usize, end: move $len };
    //         $iter = move $range;
    //         loop {
    //             $iter_mut = &mut $iter;
    //             $start_ref = &(*$iter_mut).start;
    //             $start = copy *$start_ref;
    //             $end_ref = &(*$iter_mut).end;
    //             $end = copy *$end_ref;
    //             $cmp = Lt(move $start, move $end);
    //             switchInt(move $cmp) {
    //                 false => $opt = #[lang = "None"],
    //                 _ => {
    //                     $x1 = copy (*$iter_mut).start;
    //                     $x2 = core::iter::range::Step::forward_unchecked(copy $x1, const 1_usize);
    //                     (*$iter_mut).start = move $x2;
    //                     $opt = #[lang = "Some"](copy $x1);
    //                 }
    //             }
    //             $discr = discriminant($opt);
    //             switchInt(move $discr) {
    //                 0_isize => break,
    //                 1_isize => {
    //                     $x = copy ($opt as Some).0;
    //                     $base = copy (*$self).$mem;
    //                     $offset = copy $x as isize (IntToInt);
    //                     $elem_ptr = Offset(copy $base, copy $offset);
    //                     _ = core::ptr::drop_in_place(copy $elem_ptr);
    //                 }
    //             }
    //         }
    //     }
    // }

    p_offset_by_len[
        $T: type
    ] = {
        struct $SlabT {
            $mem: *mut $T,
            $len: usize,
        }

        fn $pattern(..) -> _ {
            let $self: &mut $SlabT;
            'len:
            let $len: usize = copy (*$self).$len;
            let $len_isize: isize = move $len as isize (IntToInt);
            let $base: *mut $T = copy (*$self).$mem;
            'ptr:
            let $ptr_mut: *mut $T = Offset(copy $base, copy $len_isize);
            let $ptr: *const $T = copy $ptr_mut as *const $T (PtrToPtr);
            'read:
            let $elem: $T = copy (*$ptr);
        }
    }
}

diag {
    p_offset_by_len = {
        primary(read)                     = "pointer out of bound",
        label(ptr)                        = "pointer created here",
        label(read)                       = "pointer read here",
        // help          = "this is because `{$len}` exceeds the container's length by one",
        // suggestion(code = "({$len} - 1)") = "did you mean this",
        name                              = "offset_by_one",
    }
}
