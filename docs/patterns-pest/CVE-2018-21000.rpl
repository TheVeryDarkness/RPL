pattern CVE-2018-21000

patt {
    use alloc::vec::Vec;
    use core::ptr::non_null::NonNull;
    use core::ptr::unique::Unique;
    use alloc::raw_vec::Cap;
    use alloc::raw_vec::RawVecInner;
    use alloc::raw_vec::RawVec;
    use alloc::alloc::Global;
    use core::marker::PhantomData;
    use core::num::niche_types::UsizeNoHighBit;

    #[diag = "p_misordered_para"]
    p_u8_to_t_misordered_para_inline[
        $T: type
    ] = fn _ (..) -> _ {
        let $from_vec: Vec::<u8> = _; // _1
        let $from_vec_mut_borrow: &mut Vec::<u8> = &mut $from_vec; // _3
        let $from_vec_non_null: NonNull::<u8> = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer; // _16
        let $from_vec_mut_ptr: *mut u8 = copy $from_vec_non_null as *mut u8 (Transmute); // _2
        let $from_vec_immutable_borrow_1: &Vec::<u8> = &$from_vec; // _6
        let $from_vec_cap_usize_no_high_bit: UsizeNoHighBit = copy (*$from_vec_immutable_borrow_1).buf.inner.cap; // _18
        let $from_vec_cap_usize: usize = copy $from_vec_cap_usize_no_high_bit as usize (Transmute); // _5;
        let $tsize1: usize = SizeOf($T); // _7
        let $to_vec_cap: usize = Div(move $from_vec_cap_usize, move $tsize1); // _4
        let $from_vec_immutable_borrow_2: &Vec::<u8> = &$from_vec; // _11
        let $from_vec_len: usize = copy (*$from_vec_immutable_borrow_2).len; // _10
        let $tsize2: usize = SizeOf($T); // _12
        let $to_vec_len_usize: usize = Div(move $from_vec_len, move $tsize2); // _9
        let $to_vec_mut_ptr: *mut $T = copy $from_vec_mut_ptr as *mut $T (PtrToPtr); // _14
        let $to_vec_len_usize_no_high_bit: UsizeNoHighBit = #[Ctor] UsizeNoHighBit(copy $to_vec_len_usize); // _21
        let $to_vec_len_usize_no_high_bit_copy: UsizeNoHighBit = copy $to_vec_len_usize_no_high_bit; // _23
        let $to_vec_const_ptr: *const u8 = copy $to_vec_mut_ptr as *const u8 (PtrToPtr);//_26
        let $to_vec_non_null: NonNull::<u8> = NonNull::<u8> {
            pointer: copy $to_vec_const_ptr
        }; // _25
        let $to_vec_unique: Unique::<u8> = Unique::<u8> {
            pointer: move $to_vec_non_null,
            _marker: const PhantomData::<u8>
        }; // _24
        let $to_vec_raw_inner: RawVecInner = RawVecInner {
            ptr: move $to_vec_unique,
            cap: copy $to_vec_len_usize_no_high_bit_copy,
            alloc: const Global
        }; // _22
        let $to_vec_raw: RawVec<$T> = RawVec<$T> {
            inner: move $to_vec_raw_inner,
            _marker: const PhantomData::<$T>
        }; // _20
        'from_raw_parts:
        let $to_vec: Vec::<$T> = Vec::<$T> {
            buf: move $to_vec_raw,
            len: copy $to_vec_cap
        }; // _0
    }
    
    #[diag = "p_misordered_para"]
    p_t_to_u8_misordered_para_inline[
        $T: type
    ] = fn _ (..) -> _ {
        let $from_vec: Vec::<$T> = _; // _1
        let $from_vec_mut_borrow: &mut Vec::<$T> = &mut $from_vec; // _3
        let $from_vec_non_null: NonNull::<u8> = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer; // _13
        let $from_vec_mut_ptr: *mut $T = copy $from_vec_non_null as *mut $T (Transmute); // _2
        let $from_vec_immutable_borrow_1: &Vec::<$T> = &$from_vec; // _6
        let $from_vec_cap_usize_no_high_bit: UsizeNoHighBit = copy (*$from_vec_immutable_borrow_1).buf.inner.cap; // _18
        let $from_vec_cap_usize: usize = copy $from_vec_cap_usize_no_high_bit as usize (Transmute); // _5;
        let $tsize1: usize = SizeOf($T); // _7
        let $to_vec_cap: usize = Mul(move $from_vec_cap_usize, move $tsize1); // _4
        let $from_vec_immutable_borrow_2: &Vec::<$T> = &$from_vec; // _10
        let $from_vec_len: usize = copy (*$from_vec_immutable_borrow_2).len; // _9
        let $tsize2: usize = SizeOf($T); // _11
        let $to_vec_len_usize: usize = Mul(move $from_vec_len, move $tsize2); // _8
        let $to_vec_mut_ptr: *mut u8 = copy $from_vec_mut_ptr as *mut u8 (PtrToPtr); // _12
        let $to_vec_len_usize_no_high_bit: UsizeNoHighBit = #[Ctor] UsizeNoHighBit(copy $to_vec_len_usize); // _18
        let $to_vec_const_ptr: *const u8 = copy $to_vec_mut_ptr as *const u8 (PtrToPtr);//_22
        let $to_vec_non_null: NonNull::<u8> = NonNull::<u8> {
            pointer: copy $to_vec_const_ptr
        }; // _21
        let $to_vec_unique: Unique::<u8> = Unique::<u8> {
            pointer: move $to_vec_non_null,
            _marker: const PhantomData::<u8>
        }; // _20
        let $to_vec_raw_inner: RawVecInner = RawVecInner {
            ptr: move $to_vec_unique,
            cap: copy $to_vec_len_usize_no_high_bit,
            alloc: const Global
        }; // _19
        let $to_vec_raw: RawVec::<u8> = RawVec::<u8> {
            inner: move $to_vec_raw_inner,
            _marker: const PhantomData::<u8>
        }; // _17
        'from_raw_parts:
        let $to_vec: Vec::<u8> = Vec::<u8> {
            buf: move $to_vec_raw,
            len: copy $to_vec_cap
        }; // _0
    }

    #[diag = "p_misordered_para"]
    p_u8_to_t_misordered_para[
        $T: type
    ] = fn _ (..) -> _ {
        type VecU8 = std::vec::Vec::<u8>;
        type VecT = std::vec::Vec::<$T>;

        let $from_vec: VecU8 = _;
        let $from_vec_mut_borrow: &mut VecU8 = &mut $from_vec;
        let $from_vec_mut_ptr: *mut u8 = Vec::as_mut_ptr(move $from_vec_mut_borrow); // FIXME: std::vec::Vec::<u8>::as_mut_ptr ?;
        let $from_vec_borrow1: &VecU8 = &$from_vec;
        let $from_vec_capacity: usize = Vec::capacity(move $from_vec_borrow1);
        let $size_of_t1: usize = std::mem::size_of::<$T>();
        let $to_vec_capacity: usize = Div(move $from_vec_capacity, move $size_of_t1);
        let $from_vec_borrow2: &VecU8 = &$from_vec;
        let $from_vec_len: usize = Vec::len(move $from_vec_borrow2);
        let $size_of_t2: usize = std::mem::size_of::<$T>();
        let $to_vec_len: usize = Div(move $from_vec_len, move $size_of_t2);
        let $to_vec_ptr: *mut $T = copy $from_vec_mut_ptr as *mut $T (PtrToPtr);
        'from_raw_parts:
        let $ret: VecT =
            Vec::from_raw_parts(move $to_vec_ptr, copy $to_vec_capacity, copy $to_vec_len);
    }
    
    #[diag = "p_misordered_para"]
    p_t_to_u8_misordered_para[
        $T: type
    ] = fn _ (..) -> _ {
        type VecT = std::vec::Vec::<$T>;
        type VecU8 = std::vec::Vec::<u8>;

        let $from_vec: VecT = _;

        // FIXME: Part3 needs to be after Part1/2

        /* Part3 */
        let $from_vec_mut_borrow: &mut VecT = &mut $from_vec;
        let $from_vec_mut_ptr: *mut $T = Vec::as_mut_ptr(move $from_vec_mut_borrow);

        /* Part1 */
        let $from_vec_borrow2: &VecT = &$from_vec;
        let $from_vec_len: usize = Vec::len(move $from_vec_borrow2);
        let $size_of_t2: usize = std::mem::size_of::<$T>();
        let $to_vec_len: usize = Mul(move $from_vec_len, move $size_of_t2);

        /* Part2 */
        let $from_vec_borrow1: &VecT = &$from_vec;
        let $from_vec_capacity: usize = Vec::capacity(move $from_vec_borrow1);
        let $size_of_t1: usize = std::mem::size_of::<$T>();
        let $to_vec_capacity: usize = Mul(move $from_vec_capacity, move $size_of_t1);

        let $to_vec_ptr: *mut u8 = copy $from_vec_mut_ptr as *mut u8 (PtrToPtr);
        'from_raw_parts:
        let $ret: VecU8 =
            Vec::from_raw_parts(move $to_vec_ptr, copy $to_vec_capacity, copy $to_vec_len);
    }
}

diag {
    p_misordered_para = {
        primary(from_raw_parts) = "misordered parameters `len` and `cap` in `Vec::from_raw_parts`",
        label(from_raw_parts) = "`Vec::from_raw_parts` called here",
        help(from_raw_parts) = "the correct order is `Vec::from_raw_parts(ptr, len, cap)`",
        level = "deny",
        name = "misordered_parameters",
    }
}

// diag {
//     p_u8_to_t_misordered_para = {
//         primary(from_vec) = "the capacity of the vector is wrong",
//         level = "deny",
//         name = "u8_to_t_misordered_para",
//     }

//     p_t_to_u8_misordered_para = {
//         primary(from_vec) = "the capacity of the vector is wrong",
//         level = "deny",
//         name = "t_to_u8_misordered_para",
//     }
// }
