pattern CVE-2021-29941

patt {
    #[diag = "p_trust_len"]
    p_trust_len_inline[
        $I: type,
        $T: type,
    ] = {
        pub fn _(..) {
            let $iter: $I = _;

            'len:
            let $len: usize = std::iter::ExactSizeIterator::len(move $iter);

            let $vec: &mut alloc::vec::Vec<$T> = _;

            // 'set_len:
            // let set_len: () = alloc::vec::Vec::set_len(move vec, copy len);
            'set_len:
            ((*$vec).len) = copy $len;
        }
    }

    p_trust_len[
        $I: type,
        $T: type,
    ] = {
        pub fn _(..) {
            let $iter: $I = _;

            'len:
            let $len: usize = std::iter::ExactSizeIterator::len(move $iter);
            let $vec: &mut alloc::vec::Vec<$T> = _;

            'set_len:
            let $set_len: () = alloc::vec::Vec::set_len(move $vec, copy $len);
        }
    }

    #[diag = "p_uninitialized_slice"]
    #[const(fn_name = "from_raw_parts")]
    p_uninitialized_slice_inline[
        $T: type,
    ] = {
        pub fn _(..) {
            'len:
            let $len: usize = _;

            // let vec: std::vec::Vec<$T> = std::vec::Vec::with_capacity(_);
            let $raw_vec_inner: alloc::raw_vec::RawVecInner = alloc::raw_vec::RawVecInner::with_capacity_in(_, _, _);
            let $raw_vec: alloc::raw_vec::RawVec<$T> = alloc::raw_vec::RawVec::<$T> {
                inner: move $raw_vec_inner,
                _marker: const std::marker::PhantomData::<$T>
            };
            'vec:
            let $vec: std::vec::Vec<$T> = std::vec::Vec::<$T> { buf: move $raw_vec, len: const 0_usize };

            let $vec_ref: &alloc::vec::Vec<$T> = &$vec;

            // 'ptr:
            // let ptr: *const $T = alloc::vec::Vec::as_ptr(move vec_ref);
            let $vec_inner_non_null: alloc::raw_vec::RawVecInner = copy (*$vec_ref).buf.inner.ptr;
            'ptr:
            let $ptr: *const $T = copy $vec_inner_non_null as *const $T (Transmute);

            // let slice: &[$T] = std::slice::from_raw_parts::<'_, $T>(move ptr, copy len);
            let $slice_ptr: *const [$T] = *const [$T] from (copy $ptr, copy $len);
            'slice:
            let $slice: &[$T] = &*$slice_ptr;
        }
    }

    #[const(fn_name = "from_raw_parts")]
    p_uninitialized_slice[
        $T: type,
    ] = {
        pub fn _(..) {
            'len:
            let $len: usize = _;
            'vec:
            let $vec: alloc::vec::Vec<$T> = alloc::vec::Vec::with_capacity(_);
            let $vec_ref: &alloc::vec::Vec<$T> = &$vec;
            'ptr:
            let $ptr: *const $T = alloc::vec::Vec::as_ptr(move $vec_ref);
            'slice:
            let $slice: &[$T] = std::slice::from_raw_parts::<'_, $T>(move $ptr, copy $len);
        }
    }

    #[diag = "p_uninitialized_slice"]
    #[const(fn_name = "from_raw_parts_mut")]
    p_uninitialized_slice_mut_inline[
        $T: type,
    ] = {
        pub fn _(..) {
            // 'len:
            // let len: usize = _;

            // let vec: std::vec::Vec<$T> = std::vec::Vec::with_capacity(_);
            let $raw_vec_inner: alloc::raw_vec::RawVecInner = alloc::raw_vec::RawVecInner::with_capacity_in(_, _, _);
            let $raw_vec: alloc::raw_vec::RawVec<$T> = alloc::raw_vec::RawVec::<$T> {
                inner: move $raw_vec_inner,
                _marker: const std::marker::PhantomData::<$T>
            };
            'vec:
            let $vec: std::vec::Vec<$T> = std::vec::Vec::<$T> { buf: move $raw_vec, len: const 0_usize };

            let $vec_ref: &mut alloc::vec::Vec<$T> = &mut $vec;

            // 'ptr:
            // let ptr: *mut $T = alloc::vec::Vec::as_ptr(move vec_ref);
            let $vec_inner_non_null: std::ptr::NonNull<u8> = copy (*$vec_ref).buf.inner.ptr.pointer;
            'ptr:
            let $ptr: *mut $T = copy $vec_inner_non_null as *mut $T (Transmute);

            // 'slice:
            // let slice: &mut [$T] = std::slice::from_raw_parts_mut::<'_, $T>(move ptr, copy len);

            // FIXME: if this statement is put in the beginning, it may fail to match the code where
            // `Vec::with_capacity` is called in advance of `ExactSizeIterator::len`.
            // See `rpl_mir::matches::match_block_ends_with` for more details.
            'len:
            let $len: usize = _;

            let $slice_ptr: *mut [$T] = *mut [$T] from (copy $ptr, copy $len);
            'slice:
            let $slice: &mut [$T] = &mut *$slice_ptr;
        }
    }

    #[diag = "p_uninitialized_slice"]
    #[const(fn_name = "from_raw_parts_mut")]
    p_uninitialized_slice_mut[
        $T: type,
    ] = {
        pub fn _(..) {
            // 'len:
            // let len: usize = _;
            'vec:
            let $vec: alloc::vec::Vec<$T> = alloc::vec::Vec::with_capacity(_);
            let $vec_ref: &mut alloc::vec::Vec<$T> = &mut $vec;
            'ptr:
            let $ptr: *mut $T = alloc::vec::Vec::as_mut_ptr(move $vec_ref);
            // FIXME: if this statement is put in the beginning, it may fail to match the code where
            // `Vec::with_capacity` is called in advance of `ExactSizeIterator::len`.
            // See `rpl_mir::matches::match_block_ends_with` for more details.
            'len:
            let $len: usize = _;
            'slice:
            let $slice: &mut [$T] = std::slice::from_raw_parts_mut::<'_, $T>(move $ptr, move $len);
        }
    }
}

diag {
    p_trust_len = {
        primary(set_len) = "it is unsound to trust return value of `std::iter::ExactSizeIterator::len` and pass it to an unsafe function like `std::vec::Vec::set_len`, which may leak uninitialized memory",
        label(set_len)   = "length used here in `Vec::set_len`",
        // note             = "`std::iter::ExactSizeIterator::len` may not be implemented correctly, and it should be used as a hint rather than a fact",
        label(len)       = "`std::iter::ExactSizeIterator::len` used here",
        help             = "incorrect implementation of `std::iter::ExactSizeIterator::len` must not cause safety issues, and consider using `std::iter::TrustedLen` instead if it's stabilized",
        name             = "trust_exact_size_iterator",
    }
    p_uninitialized_slice = {
        primary(slice) = "it violates the precondition of `std::slice::{$fn_name}` to create a slice from a `Vec` that is not initialized yet",
        label(slice)   = "slice created here",
        label(vec)     = "`Vec` created but not initialized",
        label(len)     = "slice created with this length",
        label(ptr)     = "slice created with this pointer",
        help           = "See https://doc.rust-lang.org/std/slice/fn.{$fn_name}.html#safety",
        level          = "deny",
        name           = "slice_from_raw_parts_uninitialized",
    }
}
