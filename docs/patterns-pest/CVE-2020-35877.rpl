pattern CVE-2020-35877

patt {
    p_loop_offset_unchecked[$T: type] = {
        fn $pattern(..) -> _ {
            'offset:
            let $offset: usize = _; // _?0 <-> _2 ?bb0[0] <-> _2
            let $offset_1: usize = copy $offset; // _?1 <-> _3 ?bb0[1] <-> bb0[0]
            'ptr:
            let $ptr_1: *const $T = _; // _?2 <-> _4 ?bb0[2] <-> bb3[0]
            let $offset_2: usize; // _?3 <-> _13
            let $flag: bool; // _?4 <-> _12
            let $ptr_3: *const $T; // _?5 <-> _14
            let $ptr_4: *const $T; // _?6 <-> _15
            let $reference: &$T; // _?7 <-> _0
            loop { // ?bb0[3] <-> bb3[1]
                $offset_2 = copy $offset_1; // ?bb1[0] <-> bb4[0]
                $flag = Gt(move $offset_2, const 0usize); // ?bb1[1] <-> bb4[0]
                switchInt(move $flag) { // ?bb1[2]
                    0usize => {
                        'reference:
                        $reference = &(*$ptr_1); // ?bb4[0]
                        break; // ?bb4[1]
                    }
                    _ => {
                        $offset_1 = Sub(copy $offset_1, const 1usize); // ?bb5[0] <-> bb5[0]
                        $ptr_4 = copy $ptr_1; // ?bb5[1] <-> bb5[1]
                        $ptr_3 = Offset(copy $ptr_4, _); // ?bb5[2] <-> bb5[3]
                        // FIXME: we can't distinguish between the two assignments to `$ptr_1`, so we get two errors
                        $ptr_1 = move $ptr_3; // ?bb5[3] <-> bb5[4]
                        // FIXME: without this, a basic block, where there is only one goto statement, is generated
                        continue; // ?bb5[4] <-> bb5[5]
                    }
                }
            }
        }
    }
    p_unchecked_ptr_offset[$T: type] =
        p_unchecked_ptr_offset_base[$T = $T] - p_unchecked_ptr_offset_lt[$T = $T] - p_unchecked_ptr_offset_le[$T = $T] - p_unchecked_ptr_offset_gt[$T = $T] - p_unchecked_ptr_offset_ge[$T = $T] - p_unchecked_ptr_offset_const[$T = $T]
}

util {
    p_unchecked_ptr_offset_base[$T: type] = {
        fn $pattern(..) -> _ {
            'ptr:
            let $ptr: *const $T = _;
            'offset:
            let $ptr_1: *const $T = Offset(copy $ptr, _);
        }
    }
    p_unchecked_ptr_offset_lt[$T: type, $U: type] = {
        fn $pattern(..) -> _ {
            let $index: $U = _;
            'ptr:
            let $ptr: *const $T = _;
            let $cmp: bool = Lt(copy $index, _);
            'offset:
            let $ptr_1: *const $T = Offset(copy $ptr, _);
        }
    }
    p_unchecked_ptr_offset_le[$T: type, $U: type] = {
        fn $pattern(..) -> _ {
            let $index: $U = _;
            'ptr:
            let $ptr: *const $T = _;
            let $cmp: bool = Le(copy $index, _);
            'offset:
            let $ptr_1: *const $T = Offset(copy $ptr, _);
        }
    }
    p_unchecked_ptr_offset_gt[$T: type, $U: type] = {
        fn $pattern(..) -> _ {
            let $index: $U = _;
            'ptr:
            let $ptr: *const $T = _;
            let $cmp: bool = Gt(_, copy $index);
            'offset:
            let $ptr_1: *const $T = Offset(copy $ptr, _);
        }
    }
    p_unchecked_ptr_offset_ge[$T: type, $U: type] = {
        fn $pattern(..) -> _ {
            let $index: $U = _;
            'ptr:
            let $ptr: *const $T = _;
            let $cmp: bool = Ge(_, copy $index);
            'offset:
            let $ptr_1: *const $T = Offset(copy $ptr, _);
        }
    }
    p_unchecked_ptr_offset_rem[$T: type, $U: type] = {
        fn $pattern(..) -> _ {
            'ptr:
            let $ptr: *const $T = _;
            let $index: $U = Rem(_, _);
            'offset:
            let $ptr_1: *const $T = Offset(copy $ptr, copy $index);
        }
    }
    p_unchecked_ptr_offset_const[$T: type, $size: const(usize), $offset: const(usize)] = {
        fn $pattern(..) -> _ {
            let $array: &[$T; $size] = _; // _1
            let $slice_ref: &[$T] = copy $array as &[$T] (PointerCoercion(Unsize, Implicit)); // _3 bb0[0]
            let $slice_ptr: *const [$T] = &raw const (*$slice_ref); // _5 bb0[1]
            'ptr:
            let $ptr: *const $T = move $slice_ptr as *const $T (PtrToPtr); // _2 bb0[2]
            'offset:
            let $ptr_1: *const $T = Offset(copy $ptr, const $offset); // _4 bb0[4]
            let $value: &$T = &(*$ptr_1); // _0 bb0[5]
        }
    // } where {
    //     const_lt($offset, $size)
    }
}

diag {
    p_loop_offset_unchecked = {
        primary(reference) = "it is unsound to dereference a pointer that is offset using an unchecked integer",
        label(reference)   = "dereferenced here",
        label(ptr)         = "pointer created here",
        label(offset)      = "offset passed in here",
        help               = "check whether it's in bound before dereferencing",
        name               = "deref_unchecked_ptr_offset",
    }

    p_unchecked_ptr_offset = {
        primary(offset)  = "it is an undefined behavior to offset a pointer using an unchecked integer",
        label(offset)    = "offset here",
        label(ptr)       = "pointer used here",
        help             = "check whether it's in bound before offsetting",
        note             = "See the safety section in https://doc.rust-lang.org/std/primitive.pointer.html#method.offset",
        name             = "unchecked_pointer_offset",
        level            = "warn",
    }
}
